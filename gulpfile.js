"use strict";

var debug = require('debug')('webkb:build');

var _                    = require('lodash');
var path                 = require('path');
var fs                   = require('fs');
var dirRecurse           = require('recursive-readdir');
var Q                    = require('q');
var del                  = require('del');

var gulp                 = require('gulp');
var gulpIf               = require('gulp-if');
var jshint               = require('gulp-jshint');
var gutil                = require('gulp-util');
var gulpDebug            = require('gulp-debug');
var sourcemaps           = require('gulp-sourcemaps');
var rename               = require('gulp-rename');
var less                 = require('gulp-less');
var uglify               = require('gulp-uglify');
var watch                = require('gulp-watch');
var plumber              = require('gulp-plumber');
var changed              = require('gulp-changed');
var runSequence          = require('run-sequence');

var watchify             = require('watchify');
var browserify           = require('browserify');
var hbsfy                = require('hbsfy');
var babelify             = require('babelify');
var source               = require('vinyl-source-stream');
var buffer               = require('vinyl-buffer');
var merge                = require('merge-stream');
var stylish              = require('jshint-stylish');

var LessPluginCleanCSS   = require('less-plugin-clean-css');
var LessPluginAutoPrefix = require('less-plugin-autoprefix');

var cleancss             = new LessPluginCleanCSS({ advanced: true });
var autoprefix           = new LessPluginAutoPrefix({ browsers: ["last 2 versions"] });

var config               = require('./lib/utils/config');


var IS_DEVELOPMENT = config.app.environment === 'development';

var stylesDirectory = path.join(config.paths.static, 'styles');

var partialsDirectory = path.join(config.paths.templates, 'partials');

var jsDirectory = path.join(config.paths.static, 'scripts');

var jsViewsDirectory = path.join(jsDirectory, 'views');

var thirdPartyJS = [];

var browserifyOptions = _.extend({}, watchify.args, {
	debug: IS_DEVELOPMENT,
	extensions: ['.es6', '.js', '.json']
});

var hbsfyOptions = {
	extensions: ['hbs'],
	precompiler: 'handlebars'
};


var babelifyOptions = {
	sourceRoot: jsDirectory,
	presets: ['es2015'],
	extensions: ['.es6'],
	comments: IS_DEVELOPMENT,
	babelrc: false
};


var jsBlob = path.join(jsDirectory, '**/*.{js,es6}');

var partialsBlob = path.join(partialsDirectory, '**/*.hbs');

var hbsSuffixRegex = /\.hbs$/;

var es6SuffixRegex = /\.es6$/;

var jsSuffixRegex = /\.js$/;

var partialsFile = path.resolve(jsDirectory, 'partials.js');

var viewMapFile = path.resolve(jsDirectory, 'view-map.es6');

/**
 * This function generates the partials.js file which is included by the Handlebars client-side
 * init function and read by browserify into a map of partial name to function. Without this,
 * any templates used client-side will not be able to use any partials.
 *
 * @returns Promise that resolves when the file has been written, or rejects if any error occurred
 * in generating it.
 */
function _writePartialsFile() {
	var deferred = Q.defer();

	dirRecurse(partialsDirectory, function(err, files) {
		if (err) {
			deferred.reject(new Error('Error generating Handlebars partials file: ' + err));
		}

		var partialsFileText = "/* jshint node:true */\n" +
			"/* This file is autogenerated by Gulp; do not make changes to this file */\n" +
			"module.exports = {\n" + _.reduce(
			files,
			function(str, file) {
				if (!hbsSuffixRegex.test(file)) {
					return str;
				}

				var partialName = path.relative(partialsDirectory, file).replace(hbsSuffixRegex, '');

				var partialPath = path.relative(jsDirectory, file);

				if (str) {
					str += ",\n";
				}

				str += "\t" + JSON.stringify(partialName) + ": require(" + JSON.stringify(partialPath) + ")";

				return str;
			},
			""
		) + "\n};";

		return Q.nfcall(
			fs.writeFile,
			partialsFile,
			partialsFileText,
			{
				encoding: "utf8"
			}
		).then(
			function() {
				deferred.resolve();
			},
			function(err) {
				deferred.reject(err);
			}
		);
	});

	return deferred.promise;
}

function _writeViewMapFile() {
	gutil.log('Writing view map file');
	var deferred = Q.defer();

	// Make a name a valid JS identifier:
	//	- camelCase it
	//	- prepend an underscore in case the name starts with a character that
	//	  is not valid at the beginning of an identifier, such as a number
	function _viewIdentifier(viewName) {
		return '_' + _.camelCase(viewName);
	}

	dirRecurse(jsViewsDirectory, function(err, files) {
		if (err) {
			deferred.reject(new Error('Error generating view map file: ' + err));
		}

		var views = _.reduce(
			files,
			function(obj, file) {
				if (!es6SuffixRegex.test(file)) {
					return obj;
				}

				var viewName = path.relative(jsViewsDirectory, file).replace(es6SuffixRegex, '');

				var viewPath = path.relative(jsDirectory, file);

				// Node path resolution expects any relative paths to start with "." or ".."
				if (viewPath[0] !== '.') {
					viewPath = './' + viewPath;
				}

				obj[viewName] = viewPath;

				return obj;
			},
			{}
		);

		var viewMapFileText = "/* This file is autogenerated by Gulp; do not make changes to this file */\n" +
			_.reduce(
				views,
				function(str, path, name) {
					if (str) {
						str += "\n";
					}

					str += "import " + _viewIdentifier(name) + " from " + JSON.stringify(path) + ";";

					return str;
				},
				""
			) + "\n\nexport default {" +
			_.reduce(
				views,
				function(str, path, name) {
					if (str) {
						str += ",";
					}

					str += "\n\t" + JSON.stringify(name) + ": " + _viewIdentifier(name);

					return str;
				},
				""
			) + '\n};';

		return Q.nfcall(
			fs.writeFile,
			viewMapFile,
			viewMapFileText,
			{
				encoding: "utf8"
			}
		).then(
			function() {
				deferred.resolve();
			},
			function(err) {
				deferred.reject(err);
			}
		);
	});

	return deferred.promise;
}

function _changeEventToOperation(eventType) {
	var operation;

	switch(eventType) {
		case 'add': 
			operation = 'addition of';
			break;
		case 'unlink':
			operation = 'deletion of';
			break;
		case 'change':
			operation = 'changes to';
			break;
	}

	return operation;
}

function _getLintStream(files) {
	return gulp.src(_.size(files) > 0 ? files : [jsBlob])
		.pipe(jshint())
		.pipe(jshint.reporter(stylish));
}

function _compileScripts(bundler, changedFiles) {
	if (_.size(changedFiles) > 0) {
		// Ignore autogenerated files (to avoid infinite recompilation loops)
		changedFiles = _.without(changedFiles, viewMapFile, partialsFile);

		if (_.size(changedFiles) === 0) {
			return;
		}
	}

	return _writeViewMapFile().done(
		function() {
			if (_.size(changedFiles) > 0) {
				gutil.log('Recompiling scripts due to changes in the following files:\n\t' + 
					_.map(
						changedFiles,
						function(file) {
							return path.relative(__dirname, file);
						}
					)
				);
			}

			changedFiles = _.filter(
				changedFiles,
				function(file) {
					// Don't lint template files
					return !hbsSuffixRegex.test(file) &&
						// Or autogenerated files
						file !== partialsFile &&
						file !== viewMapFile;
				}
			);

			var compileStream = bundler
				.bundle()
				.on('error', function(err) {
					gutil.log(gutil.colors.red('Browserify Error\n'), err.message, err.stack || '');
				})
				.on('log', gutil.log)
				.pipe(source('build.js'))
				.pipe(buffer())
				.pipe(sourcemaps.init({
					loadMaps: true // loads map from browserify file
				}))
				.pipe(gulpIf(!IS_DEVELOPMENT, uglify()))
				.pipe(sourcemaps.write('.')) // writes .map file
				.pipe(gulp.dest(path.join(config.paths.static, 'dist', 'js/')));

			// Don't bother linting in prod environment--errors will only be fixed in dev anyway
			if (IS_DEVELOPMENT) {
				return merge(
					_getLintStream(changedFiles),
					compileStream
				);
			}

			return compileStream;
		}
	);
}

function _scriptsTask(watch) {
	var bundler = browserify([path.join(jsDirectory, 'main.es6')].concat(thirdPartyJS), browserifyOptions);
	
	if (watch) {
		bundler = watchify(bundler);
	}

	bundler.transform(hbsfy.configure(hbsfyOptions));
	
	bundler.transform(babelify.configure(babelifyOptions));

	if (watch) {
		bundler.on('update', _.bind(_compileScripts, undefined, bundler));
	}

	return _compileScripts(bundler);
}

gulp.task('scripts', function() {
	return _scriptsTask();
});

gulp.task('watch-scripts', function() {
	return _scriptsTask(true);
});

gulp.task('write-partials', function() {
	return _writePartialsFile();
});

gulp.task('watch-partials', function() {
	gulp.watch(partialsBlob, ['write-partials']);
});

gulp.task('lint', function() {
	return _getLintStream();
});

gulp.task('copy-fonts', function() {
	var fontOutPath = path.join(config.paths.static, 'dist', 'fonts');

	gulp.src(
		path.join(config.paths.static, 'node_modules', 'font-awesome', 'fonts', '**')
	).pipe(changed(fontOutPath))
	.pipe(gulp.dest(fontOutPath));
});

gulp.task('styles', ['copy-fonts'], function() {
	return gulp.src(path.join(stylesDirectory, 'main.less'))
		.pipe(gulpDebug())
		.pipe(
			plumber(
				function(err) {
					gutil.log(gutil.colors.red('LESS error:\n'), err.message, err.stack || '');
				}
			)
		)
		.pipe(sourcemaps.init())
		.pipe(less({
			modifyVars: {
				"@fa-font-path": '"../fonts"'
			},
			plugins: [cleancss, autoprefix]
		}))
		.pipe(rename({
			dirname: '',
			basename: 'build',
			extname: '.css'
		}))
		.pipe(sourcemaps.write())
		.pipe(gulp.dest(path.join(config.paths.static, 'dist', 'css/')));
});

gulp.task('watch-styles', ['styles'], function() {
	return watch(path.join(stylesDirectory, '**/*.less'), function(changedFile) {
		gutil.log(
			'Recompiling styles due to ' + _changeEventToOperation(changedFile.event) +
				' the following file: \n\t' +
				path.relative(stylesDirectory, changedFile.path)
		);

		gulp.start('styles');
	});
});

gulp.task('scripts-and-templates', function() {
	return runSequence(
		'write-partials',
		'scripts'
	);
});

gulp.task('static', ['styles', 'scripts-and-templates']);

gulp.task('watch-static', ['watch-styles', 'watch-partials', 'watch-scripts']);

gulp.task('build', ['static']);
